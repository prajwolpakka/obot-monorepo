import { Controller, Get, Res, ForbiddenException, Req, Logger } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { Request, Response } from 'express';
import { readFileSync } from 'fs';
import { join } from 'path';
import { ChatbotsService } from '../chatbots/chatbots.service';

@ApiTags('public')
@Controller()
export class PublicController {
  private readonly logger = new Logger(PublicController.name);

  constructor(private readonly chatbotsService: ChatbotsService) {}

  @Get('chatbot.js')
  @ApiOperation({ summary: 'Get chatbot widget script' })
  @ApiResponse({ status: 200, description: 'Script served successfully' })
  @ApiResponse({ status: 403, description: 'Domain not allowed' })
  async getChatbotScript(@Req() req: Request, @Res() res: Response) {
    // Get the requesting domain from headers
    const referer = req.get('referer') || req.get('origin') || '';
    const userAgent = req.get('user-agent') || '';
    
    this.logger.log(`Chatbot script request - Referer: ${referer}, UA: ${userAgent}`);

    // Check if domain is allowed for any chatbot
    const isAllowed = await this.isDomainAllowedForAnyBot(referer);
    
    if (!isAllowed) {
      this.logger.warn(`Domain access denied - Domain: ${referer}`);
      throw new ForbiddenException('Domain not allowed for chatbot integration');
    }

    this.logger.log(`Domain access granted - Domain: ${referer}`);

    // Serve the chatbot script
    const scriptPath = join(process.cwd(), 'public', 'chatbot.js');
    const script = readFileSync(scriptPath, 'utf-8');
    
    res.set({
      'Content-Type': 'application/javascript',
      'Cache-Control': 'public, max-age=3600',
      'Access-Control-Allow-Origin': this.extractDomain(referer),
      'Access-Control-Allow-Methods': 'GET',
      'Access-Control-Allow-Headers': 'Content-Type',
    });
    
    res.send(script);
  }

  private async isDomainAllowedForAnyBot(referer: string): Promise<boolean> {
    // If no referer (direct access), deny
    if (!referer) {
      return false;
    }

    // Get all active chatbots with their allowed domains
    const chatbots = await this.chatbotsService.findAllWithDomains();
    
    if (!chatbots || chatbots.length === 0) {
      return true; // If no chatbots exist, allow (default behavior)
    }

    const requestDomain = this.extractDomain(referer).toLowerCase();
    
    // Check if the requesting domain is allowed for any chatbot
    return chatbots.some(chatbot => {
      // If no allowed domains configured for this chatbot, skip it
      if (!chatbot.allowedDomains || chatbot.allowedDomains.length === 0) {
        return false;
      }

      // Check against this chatbot's allowed domains
      return chatbot.allowedDomains.some(domain => {
        const allowedDomain = domain.value.toLowerCase();
        
        // Exact match
        if (requestDomain === allowedDomain) {
          return true;
        }
        
        // Subdomain match (e.g., sub.example.com matches *.example.com or example.com)
        if (allowedDomain.startsWith('*.')) {
          const baseDomain = allowedDomain.substring(2);
          return requestDomain.endsWith('.' + baseDomain) || requestDomain === baseDomain;
        }
        
        // Check if allowed domain is a subdomain pattern
        if (requestDomain.endsWith('.' + allowedDomain)) {
          return true;
        }
        
        return false;
      });
    });
  }

  private extractDomain(url: string): string {
    if (!url) return '';
    
    try {
      const parsedUrl = new URL(url);
      return parsedUrl.origin;
    } catch (error) {
      // If URL parsing fails, try to extract domain manually
      const match = url.match(/^https?:\/\/([^\/]+)/);
      return match ? `${url.startsWith('https') ? 'https' : 'http'}://${match[1]}` : '';
    }
  }
}